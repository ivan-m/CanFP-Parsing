<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Ivan Lazar Miljenovic" />
  <title>l7:Parsing7:Bencodee</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="reveal.js/css/reveal.css"/>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; background-color: #303030; color: #cccccc; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; }
td.sourceCode { padding-left: 5px; }
pre, code { color: #cccccc; background-color: #303030; }
code > span.kw { color: #f0dfaf; } /* Keyword */
code > span.dt { color: #dfdfbf; } /* DataType */
code > span.dv { color: #dcdccc; } /* DecVal */
code > span.bn { color: #dca3a3; } /* BaseN */
code > span.fl { color: #c0bed1; } /* Float */
code > span.ch { color: #dca3a3; } /* Char */
code > span.st { color: #cc9393; } /* String */
code > span.co { color: #7f9f7f; } /* Comment */
code > span.ot { color: #efef8f; } /* Other */
code > span.al { color: #ffcfaf; } /* Alert */
code > span.fu { color: #efef8f; } /* Function */
code > span.er { color: #c3bf9f; } /* Error */
code > span.wa { color: #7f9f7f; font-weight: bold; } /* Warning */
code > span.cn { color: #dca3a3; font-weight: bold; } /* Constant */
code > span.sc { color: #dca3a3; } /* SpecialChar */
code > span.vs { color: #cc9393; } /* VerbatimString */
code > span.ss { color: #cc9393; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { } /* Variable */
code > span.cf { color: #f0dfaf; } /* ControlFlow */
code > span.op { color: #f0efd0; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #ffcfaf; font-weight: bold; } /* Preprocessor */
code > span.at { } /* Attribute */
code > span.do { color: #7f9f7f; } /* Documentation */
code > span.an { color: #7f9f7f; font-weight: bold; } /* Annotation */
code > span.cv { color: #7f9f7f; font-weight: bold; } /* CommentVar */
code > span.in { color: #7f9f7f; font-weight: bold; } /* Information */
  </style>
  <link rel="stylesheet" href="reveal.js/css/theme/night.css" id="theme">
  <link rel="stylesheet" href="custom.css"/>
  <!-- If the query includes 'print-pdf', include the PDF print sheet -->
  <script>
    if( window.location.search.match( /print-pdf/gi ) ) {
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = 'reveal.js/css/print/pdf.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
  </script>
  <!--[if lt IE 9]>
  <script src="reveal.js/lib/js/html5shiv.js"></script>
  <![endif]-->
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section>
    <h1 class="title">l7:Parsing7:Bencodee</h1>
    <h2 class="author">Ivan Lazar Miljenovic</h2>
    <h3 class="date">22 July, 2015</h3>
</section>

<section><section id="about-this-talk" class="titleslide slide level1"><h1>About this talk</h1></section><section id="feel-free-to-yell-out" class="slide level2" data-background="images/yell.jpg" data-background-color="white">
<h1>Feel free to yell out!</h1>
<h6 id="vortrag-by-oliver-tacke-cc-by"><a href="https://www.flickr.com/photos/otacke/12635014673">Vortrag</a> by Oliver Tacke / <a href="https://creativecommons.org/licenses/by/2.0/">CC BY</a></h6>
</section><section id="who-is-this-guy" class="slide level2" data-background="images/huh.jpg" data-background-color="lightblue">
<h1>Who is this guy?</h1>
<h6 id="huh-by-elio-m.-cc-by-nc"><a href="https://www.flickr.com/photos/jumpn_around/2239989214/">huh?</a> by elio m. / <a href="https://creativecommons.org/licenses/by-nc/2.0/">CC BY-NC</a></h6>
<aside class="notes">
<ul>
<li>Using Haskell since late 2007</li>
<li>Maintainer of various libraries, primarily graph related</li>
<li>Writing my own parser</li>
<li>Name very Google-able</li>
</ul>
</aside>
<dl>
</dl>
</section><section id="whats-going-to-be-covered" class="slide level2">
<h1>What’s going to be covered?</h1>
<ul>
<li class="fragment">Write a simple parser</li>
<li class="fragment">Define data types</li>
<li class="fragment">Encounter the dreaded “M”-word</li>
<li class="fragment">Survive doing so</li>
</ul>
</section><section id="want-to-skip-ahead" class="slide level2">
<h1>Want to skip ahead?</h1>
<dl>
<dt>Slides</dt>
<dd><a href="http://ivan-m.github.io/CanFP-Parsing/" class="uri">http://ivan-m.github.io/CanFP-Parsing/</a>
</dd>
<dd>(Hint: press <code>s</code> to see my secret notes!)
</dd>
<dt>Source Code</dt>
<dd><a href="https://github.com/ivan-m/CanFP-Parsing/tree/master/src" class="uri">https://github.com/ivan-m/CanFP-Parsing/tree/master/src</a>
</dd>
</dl>
</section></section>
<section><section id="why-parser-combinators" class="titleslide slide level1"><h1>Why Parser Combinators?</h1></section><section id="consider-a-common-alternative" class="slide level2">
<h1>Consider a common alternative…</h1>
<aside class="notes">
<ul>
<li>LCA 2013, Programming Miniconf</li>
<li>“Solving Interesting Problems by Writing Parsers” by Jacinta Richardson</li>
<li>Videos available</li>
<li>Perl-focussed</li>
<li>So it should be no surprise when she decided to use…</li>
</ul>
</aside>
<dl>
</dl>
</section><section id="regex-horror" class="slide level2" data-background="images/horror.jpg" data-background-color="lightblue">
<h1></h1>
<blockquote>
<p><strong>Every time you mention regular expressions, someone brings up Jamie Zawinski.</strong></p>
</blockquote>
<div class="fragment">
<blockquote>
<p><strong>Now you have two problems.</strong></p>
</blockquote>
<h6 id="shock-shock-horror-horror-by-jeremy-brooks-cc-by-nc"><a href="https://www.flickr.com/photos/jeremybrooks/2199355153/">Shock Shock Horror Horror</a> by Jeremy Brooks / <a href="https://creativecommons.org/licenses/by-nc/2.0/">CC BY-NC</a></h6>
<aside class="notes">
<ul>
<li>She even admits regexes are often the wrong solution.</li>
<li>Haskellers like Erik de Castro Lopo were watching</li>
</ul>
</aside>
<dl>
</dl>
</div>
</section><section id="why-not-regexes" class="slide level2">
<h1>Why not regexes?</h1>
<ul>
<li class="fragment">Stringly-typed</li>
<li class="fragment">Not re-usable</li>
<li class="fragment">Difficult to read</li>
<li class="fragment">Re-interpreted by compiler</li>
</ul>
<aside class="notes">
<ul>
<li>Embeddable regexes, quasiquotes, etc.</li>
</ul>
</aside>
<dl>
</dl>
</section><section id="compare-the-pair" class="slide level2">
<h1>Compare the pair</h1>
<aside class="notes">
<ul>
<li>Sample taken from Pandoc, identifier in attribute</li>
<li>regex shorter</li>
<li>Have I matched all the parens properly?</li>
<li>combinator version could be shorter</li>
<li>Which is more readable? combinable?</li>
<li>regexes more convenient for custom munging</li>
<li>I forgot the <code>char '.'</code>; which is it easier to spot in?</li>
</ul>
</aside>
<dl>
<dt>Regular Expressions</dt>
<dd><div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="st">&quot;\.\([[:alpha:]][[:alnum:]-_:\.]*\)&quot;</span></code></pre></div>
</dd>
<dt>Parser Combinators</dt>
<dd><div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">identifierAttr <span class="fu">=</span> <span class="kw">do</span>
  char <span class="ch">&#39;.&#39;</span>
  first <span class="ot">&lt;-</span> letter
  rest <span class="ot">&lt;-</span> many <span class="fu">$</span> alphaNum
                 <span class="fu">&lt;|&gt;</span> oneOf <span class="st">&quot;-_:.&quot;</span>
  return (first<span class="fu">:</span>rest)</code></pre></div>
</dd>
</dl>
</section><section id="what-about-parser-generators" class="slide level2">
<h1>What about Parser Generators?</h1>
<aside class="notes">
<ul>
<li><em>Requires</em> a grammar</li>
<li>Combinators easier to extend</li>
<li>Probably faster</li>
<li>Can emulate in a parser combinator</li>
<li>Not embeddable in code</li>
<li>Usually needs an external tool</li>
</ul>
</aside>
<dl>
</dl>
</section><section id="availability-of-parser-combinators" class="slide level2">
<h1>Availability of parser combinators</h1>
<ul>
<li>Most (all?) FP languages</li>
<li>Javascript</li>
<li>R</li>
<li>Java</li>
<li>C#</li>
<li>etc.</li>
</ul>
<div class="fragment">
<blockquote>
<p><strong>Not just for data!</strong></p>
</blockquote>
<aside class="notes">
<ul>
<li>Multiple implementations (parsec, attoparsec, polyparse, trifecta, etc.)</li>
<li>Rite of passage!</li>
<li>If Java has it, <em>of course</em> C# has to have it to prove they’re better…</li>
</ul>
</aside>
<dl>
</dl>
</div>
</section></section>
<section><section id="bencode" class="titleslide slide level1"><h1>Bencode</h1></section><section id="what-is-bencode" class="slide level2">
<h1>What is Bencode?</h1>
<ul>
<li class="fragment">Encoding used by BitTorrent for storing/transmitting data</li>
<li class="fragment">Comprised of four different types of values:</li>
</ul>
<div class="fragment">
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: center;">Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Integers</td>
<td style="text-align: center;"><code>i42e</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">Strings</td>
<td style="text-align: center;"><code>4:spam</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Lists</td>
<td style="text-align: center;"><code>l4:spami42ee</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">Dictionaries</td>
<td style="text-align: center;"><code>d3:bar4:spam3:fooi42ee</code></td>
</tr>
</tbody>
</table>
<aside class="notes">
<ul>
<li>Suggested by Mats H</li>
<li>Dictionaries require keys to be strings</li>
</ul>
</aside>
<dl>
</dl>
</div>
</section><section id="simplifications" class="slide level2">
<h1>Simplifications</h1>
<ul>
<li>Use normal strings, not byte strings</li>
<li>No validation checks (e.g. allow <code>-0</code>)</li>
<li>Ignore dictionary ordering</li>
</ul>
<aside class="notes">
<ul>
<li>Strings should be a sequence of bytes</li>
<li>Dictionaries should be lexicographically ordered by keys</li>
</ul>
</aside>
<dl>
</dl>
</section><section id="datatypes-are-awesome" class="slide level2" data-background="images/awesome.jpg" data-background-color="lightblue">
<h1>Datatypes are Awesome!</h1>
<div class="fragment">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Bencode</span> <span class="fu">=</span> <span class="dt">BInt</span> <span class="dt">Int</span>
             <span class="fu">|</span> <span class="dt">BString</span> <span class="dt">String</span>
             <span class="fu">|</span> <span class="dt">BList</span> [<span class="dt">Bencode</span>]
             <span class="fu">|</span> <span class="dt">BDict</span> [(<span class="dt">String</span>, <span class="dt">Bencode</span>)]
             <span class="kw">deriving</span> (<span class="dt">Show</span>)</code></pre></div>
<h6 id="bboy-and-his-friends-by-crises_crs-cc-by-nc"><a href="https://www.flickr.com/photos/33774513@N08/3153440876/">Bboy and his friends</a> by crises_crs / <a href="https://creativecommons.org/licenses/by-nc/2.0/">CC BY-NC</a></h6>
</div>
</section></section>
<section><section id="defining-the-parser" class="titleslide slide level1"><h1>Defining the Parser</h1></section><section id="what-is-a-parser" class="slide level2">
<h1>What is a parser?</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Parser</span> a <span class="fu">=</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a</code></pre></div>
<aside class="notes">
<ul>
<li>Most basic definition of what a parser is</li>
<li>Is that it?</li>
</ul>
</aside>
<dl>
</dl>
</section><section id="consider-parsing-an-integer" class="slide level2">
<h1>Consider parsing an integer</h1>
<ul>
<li class="fragment">Let’s parse <code>i42e</code></li>
<li class="fragment">Imagine a function <code>next :: Parser Char</code></li>
</ul>
<aside class="notes">
<ul>
<li>I first need to get the first char to get <code>i</code></li>
<li>Now what?</li>
<li>The input is all used up!</li>
</ul>
</aside>
<dl>
</dl>
</section><section id="attempt-2" class="slide level2">
<h1>Attempt 2</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Parser</span> a <span class="fu">=</span> <span class="dt">String</span> <span class="ot">-&gt;</span> (a, <span class="dt">String</span>)</code></pre></div>
<aside class="notes">
<ul>
<li>Returns un-consumed input</li>
<li>What happens if it <em>isn’t</em> an integer?</li>
<li>This says it always returns a value!</li>
</ul>
</aside>
<dl>
</dl>
</section><section id="attempt-3" class="slide level2">
<h1>Attempt 3</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- The result of a parser: either an error or the expected result.</span>
<span class="kw">data</span> <span class="dt">Result</span> a <span class="fu">=</span> <span class="dt">Err</span> <span class="dt">String</span>
              <span class="fu">|</span> <span class="dt">OK</span> a
              <span class="kw">deriving</span> (<span class="dt">Show</span>)

<span class="kw">type</span> <span class="dt">Parser</span> a <span class="fu">=</span> <span class="dt">String</span> <span class="ot">-&gt;</span> (<span class="dt">Result</span> a, <span class="dt">String</span>)</code></pre></div>
<aside class="notes">
<ul>
<li>Up to isomorphism of how result is returned</li>
<li>Complete in terms of being able to work</li>
<li>Can be bypassed</li>
</ul>
</aside>
<dl>
</dl>
</section><section id="final-definition" class="slide level2">
<h1>Final definition</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Parser</span> a <span class="fu">=</span> <span class="dt">P</span> {<span class="ot"> runP ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> (<span class="dt">Result</span> a, <span class="dt">String</span>) }</code></pre></div>
<div class="fragment">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Shhhhhh!!!!!</span>
<span class="kw">newtype</span> <span class="dt">State</span> s a <span class="fu">=</span> <span class="dt">St</span> {<span class="ot"> runState ::</span> s <span class="ot">-&gt;</span> (a, s) }</code></pre></div>
<aside class="notes">
<ul>
<li>Don’t export constructor</li>
<li><code>runP</code> runs the parser</li>
<li><code>newtype</code> is run-time isomorphic to original</li>
<li>Specialised version of State Monad</li>
</ul>
</aside>
<dl>
</dl>
</div>
</section></section>
<section><section id="lets-start-parsing" class="titleslide slide level1"><h1>Let’s start parsing!</h1></section><section id="create-basic-parsers" class="slide level2">
<h1>Create basic parsers</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Lift a value into a parser.</span>
<span class="ot">toParser ::</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a
toParser a <span class="fu">=</span> <span class="dt">P</span> <span class="fu">$</span> \str <span class="ot">-&gt;</span> (<span class="dt">OK</span> a, str)

<span class="co">-- Throw a parser error.</span>
<span class="ot">failParser ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> a
failParser err <span class="fu">=</span> <span class="dt">P</span> <span class="fu">$</span> \str <span class="ot">-&gt;</span> (<span class="dt">Err</span> err, str)</code></pre></div>
</section><section id="get-some-data" class="slide level2">
<h1>Get some data</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Obtain the next character in the input string.</span>
<span class="ot">next ::</span> <span class="dt">Parser</span> <span class="dt">Char</span>
next <span class="fu">=</span> <span class="dt">P</span> <span class="fu">$</span> \str <span class="ot">-&gt;</span> <span class="kw">case</span> str <span class="kw">of</span>
                     c<span class="fu">:</span>str&#39; <span class="ot">-&gt;</span> (<span class="dt">OK</span> c, str&#39;)
                     _      <span class="ot">-&gt;</span> (<span class="dt">Err</span> <span class="st">&quot;empty&quot;</span>, str)</code></pre></div>
</section><section id="matching-a-predicate" class="slide level2">
<h1>Matching a predicate</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">satisfy ::</span> (<span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">Char</span>
satisfy p <span class="fu">=</span> <span class="dt">P</span> <span class="fu">$</span> \str <span class="ot">-&gt;</span>
  <span class="kw">case</span> str <span class="kw">of</span>
    c<span class="fu">:</span>str&#39; <span class="fu">|</span> p c       <span class="ot">-&gt;</span> (<span class="dt">OK</span> c, str&#39;)
           <span class="fu">|</span> otherwise <span class="ot">-&gt;</span> (<span class="dt">Err</span> <span class="st">&quot;not satisfied&quot;</span>, str)
    _                  <span class="ot">-&gt;</span> (<span class="dt">Err</span> <span class="st">&quot;empty&quot;</span>, str)

<span class="co">-- For example: parse the specified character.</span>
<span class="ot">char ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">Char</span>
char c <span class="fu">=</span> satisfy (c<span class="fu">==</span>)</code></pre></div>
<aside class="notes">
<ul>
<li>When parsing an integer, we want <code>isDigit</code> (see later)</li>
<li>This looks an awful lot like <code>next</code></li>
<li>Idea: call next, get the result, then act on it.</li>
</ul>
</aside>
<dl>
</dl>
</section><section id="matching-again" class="slide level2">
<h1>Matching again</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Take the result from one parser, and pass it as a parameter to a</span>
<span class="co">-- function that returns a parser.</span>
<span class="ot">inject ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Parser</span> b) <span class="ot">-&gt;</span> <span class="dt">Parser</span> b
inject pa fpb <span class="fu">=</span> <span class="dt">P</span> <span class="fu">$</span> \str <span class="ot">-&gt;</span> <span class="kw">case</span> runP pa str <span class="kw">of</span>
                              (<span class="dt">OK</span> a,  str&#39;) <span class="ot">-&gt;</span> runP (fpb a) str&#39;
                              (<span class="dt">Err</span> e, str&#39;) <span class="ot">-&gt;</span> (<span class="dt">Err</span> e, str&#39;)

<span class="ot">satisfy ::</span> (<span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">Char</span>
satisfy p <span class="fu">=</span> next <span class="ot">`inject`</span> checkNext
  <span class="kw">where</span>
    checkNext c
      <span class="fu">|</span> p c       <span class="fu">=</span> toParser c
      <span class="fu">|</span> otherwise <span class="fu">=</span> failParser <span class="st">&quot;not satisfied&quot;</span></code></pre></div>
<aside class="notes">
<ul>
<li>Better!</li>
<li><code>inject</code> is a handy concept</li>
</ul>
</aside>
<dl>
</dl>
</section><section id="getting-multiple-digits" class="slide level2">
<h1>Getting multiple digits</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Char</span>(isDigit)

<span class="ot">atLeastOnce ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> [<span class="dt">Parser</span> a]
atLeastOnce <span class="fu">=</span> <span class="co">-- to be implemented</span>

<span class="ot">parseIntDigits ::</span> <span class="dt">Parser</span> <span class="dt">String</span>
parseIntDigits <span class="fu">=</span> atLeastOnce (satisfy isDigit)</code></pre></div>
<aside class="notes">
<ul>
<li>Ignoring negative numbers for now</li>
<li>Sample code has it implemented though</li>
</ul>
</aside>
<dl>
</dl>
</section><section id="but-i-want-a-number" class="slide level2">
<h1>But I want a number!</h1>
<p>Need to convert a <code>String</code> to an <code>Int</code>…</p>
<div class="fragment">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Apply a function on the result of a parser.</span>
<span class="ot">mapParser ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> b
mapParser f pa <span class="fu">=</span> <span class="dt">P</span> <span class="fu">$</span> \str <span class="ot">-&gt;</span> <span class="kw">case</span> runP pa str <span class="kw">of</span>
                               (<span class="dt">OK</span> a,  str&#39;) <span class="ot">-&gt;</span> (<span class="dt">OK</span> (f a), str&#39;)
                               (<span class="dt">Err</span> e, str&#39;) <span class="ot">-&gt;</span> (<span class="dt">Err</span> e, str&#39;)

<span class="ot">parseInt ::</span> <span class="dt">Parse</span> <span class="dt">Int</span>
parseInt <span class="fu">=</span> mapParser read parseIntDigits</code></pre></div>
<aside class="notes">
<ul>
<li>Talk about <code>read</code></li>
<li>Real code, might use something better</li>
</ul>
</aside>
<dl>
</dl>
</div>
</section><section id="that-function-looks-familiar" class="slide level2">
<h1>That function looks familiar</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mapParser ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Parser</span> a  <span class="ot">-&gt;</span> <span class="dt">Parser</span> b

map<span class="ot">       ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span>       [a] <span class="ot">-&gt;</span>       [b]

<span class="co">-- Let&#39;s generalise</span>

<span class="ot">mapF      ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f      a  <span class="ot">-&gt;</span> f      b</code></pre></div>
</section><section id="thats-func-tastic" class="slide level2">
<h1>That’s Func-tastic!</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="kw">where</span>
<span class="ot">  fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b

<span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Parser</span> <span class="kw">where</span>
  fmap <span class="fu">=</span> mapParser</code></pre></div>
<p>With the handy in-fix alias of <code>&lt;$&gt;</code>.</p>
<aside class="notes">
<ul>
<li><code>&lt;$&gt;</code> vs <code>$</code></li>
<li>Functor laws</li>
</ul>
</aside>
<dl>
</dl>
</section><section id="discarding" class="slide level2">
<h1>Discarding</h1>
<p>Imagine these combinators:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">discLeft ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> b <span class="ot">-&gt;</span> <span class="dt">Parser</span> b

<span class="ot">discRight ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> b <span class="ot">-&gt;</span> <span class="dt">Parser</span> a

<span class="co">-- Run a parser on either side of the one specified.</span>
<span class="ot">bracket ::</span> <span class="dt">Parser</span> bra <span class="ot">-&gt;</span> <span class="dt">Parser</span> ket <span class="ot">-&gt;</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a
bracket pb pk pa <span class="fu">=</span> pb <span class="ot">`discLeft`</span> (pa <span class="ot">`discRight`</span> pk)

<span class="ot">parseBInt ::</span> <span class="dt">Parser</span> <span class="dt">Bencode</span>
parseBInt <span class="fu">=</span> <span class="dt">BInt</span> <span class="fu">&lt;$&gt;</span> bracket (char <span class="ch">&#39;i&#39;</span>) (char <span class="ch">&#39;e&#39;</span>) parseInt</code></pre></div>
<aside class="notes">
<ul>
<li>The discard functions can be obtained by lifting <code>const</code> and <code>flip const</code> up into the <code>Parser</code>.</li>
</ul>
</aside>
<dl>
</dl>
</section><section id="applying-lifted-functions" class="slide level2">
<h1>Applying lifted functions</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">applyFunc ::</span> <span class="dt">Parser</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> b
applyFunc pf pa <span class="fu">=</span> pf <span class="ot">`inject`</span>
                      (\f <span class="ot">-&gt;</span> pa <span class="ot">`inject`</span>
                                (\a <span class="ot">-&gt;</span> toParser (f a)))

<span class="ot">discLeft ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> b <span class="ot">-&gt;</span> <span class="dt">Parser</span> b
discLeft pa pb <span class="fu">=</span> (flip const <span class="fu">&lt;$&gt;</span> pa) <span class="ot">`applyFunc`</span> pb

<span class="ot">discRight ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> b <span class="ot">-&gt;</span> <span class="dt">Parser</span> a
discRight pa pb <span class="fu">=</span> (const <span class="fu">&lt;$&gt;</span> pa) <span class="ot">`applyFunc`</span> pb</code></pre></div>
<aside class="notes">
<ul>
<li>This would look neater if I set up the proper fixities (less parens)</li>
<li>But this way it’s more obvious</li>
</ul>
</aside>
<dl>
</dl>
</section><section id="introducing-applicative" class="slide level2">
<h1>Introducing Applicative!</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Applicative</span> f <span class="kw">where</span>
    <span class="co">-- Lift a value.</span>
<span class="ot">    pure ::</span> a <span class="ot">-&gt;</span> f a

    <span class="co">-- Sequential application.</span>
<span class="ot">    (&lt;*&gt;) ::</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b

<span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Parser</span> <span class="kw">where</span>
  pure <span class="fu">=</span> toParser
  (<span class="fu">&lt;*&gt;</span>) <span class="fu">=</span> applyFunc

<span class="ot">bracket ::</span> <span class="dt">Parser</span> bra <span class="ot">-&gt;</span> <span class="dt">Parser</span> ket <span class="ot">-&gt;</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a
bracket pb pk pa <span class="fu">=</span> pb <span class="fu">*&gt;</span> pa <span class="fu">&lt;*</span> pk</code></pre></div>
<aside class="notes">
<ul>
<li><code>*&gt;</code> and <code>&lt;*</code> pre-defined, along with other combinators</li>
<li><code>parseBInt</code> doesn’t change</li>
</ul>
</aside>
<dl>
</dl>
</section><section id="we-still-need-to-get-the-digits" class="slide level2">
<h1>We still need to get the digits</h1>
<ol type="1">
<li class="fragment">Try our parser <code>p</code>.</li>
<li class="fragment">If it fails, no values, so return an empty list <code>[]</code>.</li>
<li class="fragment">Otherwise, recurse and put this value on the front of the list.</li>
</ol>
<aside class="notes">
<ul>
<li>We want to get a list of values</li>
<li>We can handle putting the value on front with Applicative</li>
</ul>
</aside>
<dl>
</dl>
</section><section id="handling-backtracking" class="slide level2">
<h1>Handling backtracking</h1>
<ol type="1">
<li class="fragment"><code>try</code>-based semantics</li>
<li class="fragment"><code>commit</code>-based semantics</li>
<li class="fragment">“Just do it already”-based semantics</li>
</ol>
<aside class="notes">
<ul>
<li>Three differeint ways of handling backtracking</li>
<li>Forget the <code>try</code>? No backtracking</li>
<li>Forget the <code>commit</code>? Still works, just less performance and worse errors (<em>“Partial Parsing: combining choice with commitment”</em> by Malcolm Wallace)</li>
<li>Doing it, as epitomised by <code>attoparsec</code>.</li>
</ul>
</aside>
<dl>
</dl>
</section><section id="failing-gracefully" class="slide level2">
<h1>Failing gracefully</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- If the first parser fails, try the second.</span>
<span class="ot">onFail ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a
onFail p1 p2 <span class="fu">=</span> <span class="dt">P</span> <span class="fu">$</span> \str <span class="ot">-&gt;</span> <span class="kw">case</span> runP p1 str <span class="kw">of</span>
                             (<span class="dt">Err</span> _, _) <span class="ot">-&gt;</span> runP p2 str
                             ok         <span class="ot">-&gt;</span> ok</code></pre></div>
</section><section id="trust-me-theres-a-class-for-it" class="slide level2">
<h1>Trust me, there’s a class for it</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Alternative</span> f <span class="kw">where</span>
    <span class="co">-- The identity of &#39;&lt;|&gt;&#39;</span>
<span class="ot">    empty ::</span> f a
    <span class="co">-- An associative binary operation</span>
<span class="ot">    (&lt;|&gt;) ::</span> f a <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f a

<span class="kw">instance</span> <span class="dt">Alternative</span> <span class="dt">Parser</span> <span class="kw">where</span>
  empty <span class="fu">=</span> failParser <span class="st">&quot;empty value&quot;</span>
  (<span class="fu">&lt;|&gt;</span>) <span class="fu">=</span> onFail

<span class="co">-- Try to parse one of the provided parsers in sequence.</span>
<span class="ot">oneOf ::</span> [<span class="dt">Parser</span> a] <span class="ot">-&gt;</span> <span class="dt">Parser</span> a
oneOf []     <span class="fu">=</span> fail <span class="st">&quot;No parsers remaining&quot;</span>
oneOf (p<span class="fu">:</span>ps) <span class="fu">=</span> p <span class="fu">&lt;|&gt;</span> oneOf ps</code></pre></div>
<aside class="notes">
<ul>
<li>This class comes from parser libraries</li>
<li>Parsec still (?) uses it’s own <code>&lt;|&gt;</code>.</li>
<li>Comes with <code>many</code> and <code>some</code> (which I called <code>atLeastOnce</code>).</li>
</ul>
</aside>
<dl>
</dl>
</section><section id="finally-we-have-integers" class="slide level2">
<h1>Finally, we have Integers!</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parseInt ::</span> <span class="dt">Parse</span> <span class="dt">Int</span>
parseInt <span class="fu">=</span> read <span class="fu">&lt;$&gt;</span> some (satisfy isDigit)

<span class="ot">parseBInt ::</span> <span class="dt">Parser</span> <span class="dt">Bencode</span>
parseBInt <span class="fu">=</span> <span class="dt">BInt</span> <span class="fu">&lt;$&gt;</span> bracket (char <span class="ch">&#39;i&#39;</span>) (char <span class="ch">&#39;e&#39;</span>) parseInt</code></pre></div>
</section><section id="time-for-strings" class="slide level2">
<h1>Time for Strings</h1>
<ol type="1">
<li class="fragment">Parse a (non-negative) integer <code>n</code></li>
<li class="fragment">Parse a <code>:</code></li>
<li class="fragment">Return the next <code>n</code> characters</li>
</ol>
<div class="fragment">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parseString ::</span> <span class="dt">Parser</span> <span class="dt">String</span>
parseString <span class="fu">=</span> parseInt
              <span class="ot">`inject`</span>
              (\n <span class="ot">-&gt;</span> char <span class="ch">&#39;:&#39;</span> <span class="fu">*&gt;</span> exactly n next)

<span class="co">-- Run the parser the specified number of times.</span>
<span class="ot">exactly ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> [a]
exactly n p
  <span class="fu">|</span> n <span class="fu">&lt;=</span> <span class="dv">0</span>    <span class="fu">=</span> pure []
  <span class="fu">|</span> otherwise <span class="fu">=</span> liftA2 (<span class="fu">:</span>) p (exactly (n<span class="fu">-</span><span class="dv">1</span>) p)</code></pre></div>
</div>
</section><section id="i-wish-there-was-a-nicer-syntax-for-inject" class="slide level2">
<h1>I wish there was a nicer syntax for inject…</h1>
<div class="fragment">
<blockquote>
<p>But there is!</p>
</blockquote>
</div>
</section><section id="warm-fuzzy-things" class="slide level2">
<h1>Warm Fuzzy Things</h1>
<ul>
<li class="fragment">aka <em>Workflows</em></li>
<li class="fragment"><del>aka <em>Burritos</em></del></li>
<li class="fragment">aka “a monoid in the category of endofunctors”</li>
<li class="fragment">aka <span style="font-variant: small-caps;"><em>Monads</em></span></li>
</ul>
<aside class="notes">
<ul>
<li>Workflows are from F#</li>
<li>SPJ: Our biggest mistake: Using the scary term “monad” rather than “warm fuzzy thing” (Wearing the hair shirt: a retrospective on Haskell (2003))</li>
<li>“monoid” from “A Brief, Incomplete, and Mostly Wrong History of Programming Languages” by James Iry (supposedly Philip Wadler)</li>
<li>Burritos from: Abstraction, intuition, and the “monad tutorial fallacy” by Brent Yorgey</li>
</ul>
</aside>
<dl>
</dl>
</section><section id="the-m-word" class="slide level2">
<h1>The “M” word</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> <span class="dt">Monad</span> m <span class="kw">where</span>
    <span class="co">-- Usually called &quot;bind&quot;</span>
<span class="ot">    (&gt;&gt;=) ::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b
<span class="ot">    (&gt;&gt;) ::</span> m a <span class="ot">-&gt;</span> m b <span class="ot">-&gt;</span> m b
<span class="ot">    return ::</span> a <span class="ot">-&gt;</span> m a
<span class="ot">    fail ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> m a

<span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Parser</span> <span class="kw">where</span>
  (<span class="fu">&gt;&gt;=</span>) <span class="fu">=</span> inject
  (<span class="fu">&gt;&gt;</span>) <span class="fu">=</span> (<span class="fu">*&gt;</span>)
  return <span class="fu">=</span> pure
  fail <span class="fu">=</span> failParser</code></pre></div>
<aside class="notes">
<ul>
<li><code>Applicative</code> constraint as of GHC 7.10 (AMP)</li>
<li><code>return</code> and <code>(*&gt;)</code> have these by default.</li>
<li><code>fail</code> is considered a wart; used for pattern matching failures</li>
<li>Replace <code>fail</code> with a new class (e.g. <code>MonadPlus</code>)?</li>
<li>Parsers possibly only semi-valid use of <code>fail</code>.</li>
</ul>
</aside>
<dl>
</dl>
</section><section id="strings-again" class="slide level2">
<h1>Strings again</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parseString ::</span> <span class="dt">Parser</span> <span class="dt">String</span>
parseString <span class="fu">=</span> <span class="kw">do</span> n <span class="ot">&lt;-</span> parseInt
                 char <span class="ch">&#39;:&#39;</span>
                 exactly n next

<span class="ot">parseBString ::</span> <span class="dt">Parser</span> <span class="dt">Bencode</span>
parseBString <span class="fu">=</span> <span class="dt">BString</span> <span class="fu">&lt;$&gt;</span> parseString</code></pre></div>
<aside class="notes">
<ul>
<li>Sequential-style operations!</li>
<li>“In short, Haskell is the world’s finest imperative programming language.” (SPJ, “Tackling the Awkward Squad”)</li>
<li><code>a &lt;- m; ...</code> equivalent to <code>m &gt;&gt;= (\a -&gt; ...)</code></li>
<li><code>m1; m2</code> equivalent to <code>m1 &gt;&gt; m2</code></li>
</ul>
</aside>
<dl>
</dl>
</section><section id="finishing-it-off" class="slide level2">
<h1>Finishing it off</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parseBList ::</span> <span class="dt">Parser</span> <span class="dt">Bencode</span>
parseBList <span class="fu">=</span> <span class="dt">BList</span> <span class="fu">&lt;$&gt;</span> bracket (char <span class="ch">&#39;l&#39;</span>) (char <span class="ch">&#39;e&#39;</span>)
                               (many parseBencode)

<span class="ot">parseBDict ::</span> <span class="dt">Parser</span> <span class="dt">Bencode</span>
parseBDict <span class="fu">=</span> <span class="dt">BDict</span> <span class="fu">&lt;$&gt;</span> bracket (char <span class="ch">&#39;d&#39;</span>) (char <span class="ch">&#39;e&#39;</span>) (many parseKV)
  <span class="kw">where</span>
    parseKV <span class="fu">=</span> liftA2 (,) parseString parseBencode

<span class="ot">parseBencode ::</span> <span class="dt">Parser</span> <span class="dt">Bencode</span>
parseBencode <span class="fu">=</span> oneOf [ parseBInt, parseBString
                     , parseBList, parseBDict
                     ]</code></pre></div>
<aside class="notes">
<ul>
<li>Mutual recursion is fun!</li>
</ul>
</aside>
<dl>
</dl>
</section><section id="trying-it-out" class="slide level2">
<h1>Trying it out</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> runP parseBencode <span class="st">&quot;l7:Parsing7:Bencodee&quot;</span>
(<span class="dt">OK</span> (<span class="dt">BList</span> [<span class="dt">BString</span> <span class="st">&quot;Parsing&quot;</span>,<span class="dt">BString</span> <span class="st">&quot;Bencode&quot;</span>]),<span class="st">&quot;&quot;</span>)</code></pre></div>
</section></section>
<section><section id="where-to-from-here" class="titleslide slide level1"><h1>Where to from here?</h1></section><section id="improve-current-parser" class="slide level2">
<h1>Improve current parser</h1>
<ul>
<li>Negative numbers</li>
<li>Ensure <code>-0</code> is illegal</li>
<li>Strings can’t have negative length</li>
<li>Parse bytes, not characters</li>
<li>Improve error messages</li>
</ul>
<aside class="notes">
<ul>
<li>Source already supports -ve numbers</li>
</ul>
</aside>
<dl>
</dl>
</section><section id="write-a-better-parser" class="slide level2">
<h1>Write a better Parser?</h1>
<blockquote>
<p><strong>Datatypes are awesome…</strong></p>
</blockquote>
<div class="fragment">
<blockquote>
<p><strong>… but functions are even <em>more</em> awesome!</strong></p>
</blockquote>
<aside class="notes">
<ul>
<li>Avoid context-switching on the <code>Result</code> type.</li>
</ul>
</aside>
<dl>
</dl>
</div>
</section><section id="continuation-parsing-style" class="slide level2">
<h1>Continuation Parsing Style</h1>
<p>Some helper definitions first:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Failure</span>   r <span class="fu">=</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ErrMsg</span> <span class="ot">-&gt;</span> <span class="dt">Result</span> r
<span class="kw">type</span> <span class="dt">Success</span> a r <span class="fu">=</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a      <span class="ot">-&gt;</span> <span class="dt">Result</span> r

<span class="kw">data</span> <span class="dt">Result</span> a <span class="fu">=</span> <span class="dt">Err</span> <span class="dt">String</span> <span class="dt">ErrMsg</span>
              <span class="fu">|</span> <span class="dt">OK</span> <span class="dt">String</span> a
              <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>, <span class="dt">Read</span>)

<span class="co">-- To avoid mixing our types up.</span>
<span class="kw">type</span> <span class="dt">ErrMsg</span> <span class="fu">=</span> <span class="dt">String</span></code></pre></div>
<aside class="notes">
<ul>
<li>Note different definition of <code>Result</code>.</li>
<li>Based loosely upon <code>attoparsec</code></li>
</ul>
</aside>
<dl>
</dl>
</section><section id="cps-parser" class="slide level2">
<h1>CPS Parser</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE RankNTypes #-}</span>

<span class="kw">newtype</span> <span class="dt">Parser</span> a <span class="fu">=</span> <span class="dt">P</span> {
<span class="ot">      runP ::</span> forall r<span class="fu">.</span> <span class="dt">String</span>
           <span class="ot">-&gt;</span> <span class="dt">Failure</span>   r
           <span class="ot">-&gt;</span> <span class="dt">Success</span> a r
           <span class="ot">-&gt;</span> <span class="dt">Result</span> r
    }</code></pre></div>
</section><section id="running-a-cps-parser" class="slide level2">
<h1>Running a CPS Parser</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">failK ::</span> <span class="dt">Failure</span> a
failK str msg <span class="fu">=</span> <span class="dt">Err</span> str msg

<span class="ot">successK ::</span> <span class="dt">Success</span> a a
successK str a <span class="fu">=</span> <span class="dt">OK</span> str a

<span class="ot">runParser ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Result</span> a
runParser p str <span class="fu">=</span> runP p str failK successK</code></pre></div>
</section><section id="exercise" class="slide level2">
<h1>Exercise</h1>
<blockquote>
<p><strong>Complete the CPS parser definition!</strong></p>
</blockquote>
<div class="fragment">
<blockquote>
<p><strong>Once you have the instances and <code>next</code> defined, the rest should be (almost) identical.</strong></p>
</blockquote>
<aside class="notes">
Source definition not yet complete, will be Real Soon Now (TM).
</aside>
<dl>
</dl>
</div>
</section><section id="so-long-and-thanks-for-all-the-fish" class="slide level2" data-background="images/fish.jpg" data-background-color="lightblue">
<h1>So long and thanks for all the fish!</h1>
<h6 id="leaping_dolphins-by-zest-pk-cc-by"><a href="https://www.flickr.com/photos/zest-pk/923931403">leaping_dolphins</a> by Zest-pk / <a href="https://creativecommons.org/licenses/by/2.0/">CC BY</a></h6>
</section></section>
    </div>
  </div>


  <script src="reveal.js/lib/js/head.min.js"></script>
  <script src="reveal.js/js/reveal.js"></script>

  <script>

      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,         // Display controls in the bottom right corner
        progress: true,         // Display a presentation progress bar
        history: true,          // Push each slide change to the browser history
        zoomKey: 'shift',
        center: true,                       // Vertical centering of slides
        maxScale: 1.5,                  // Bounds for smallest/largest possible content scale
        slideNumber: false,                // Display the page number of the current slide
        theme: 'night', // available themes are in /css/theme
        transition: 'concave', // default/cube/page/concave/zoom/linear/fade/none
        backgroundTransition: 'zoom', // default/none/fade/slide/convex/concave/zoom

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: 'reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
//          { src: 'reveal.js/plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; }, }
//          { src: 'reveal.js/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
]});
    </script>
    </body>
</html>
